{
	"BLOGS":[
		{
			"title": "关于本站",
			"date": "2016.02.15",
			"content": "----------Update---------\n\n说一下project页面下面有箭头可以向左向右的。。然后增加了google analytics\n\n--------Update-------\n\n增加了[Disqus](https://disqus.com/home/explore/)作为评论系统，遗憾的是不能改字体。\n\n--------原文--------\n\n春节不上班，闲来无事就在家里写了一个个人网页。\n\n其实本意是想介绍一下自己，算是一份小小的简历，但在是否将博客功能嵌入这个问题上纠结许久，最后还是想直接集成在一个网页中。目前还没有用市面上的一些Blog框架，之后会考虑使用[Jekyll](http://jekyllrb.com)，不过都是后话了。\n\n说说用到的技术吧。\n\nLow Poly图用的是[Polyvia](http://zhangwenli.com/Polyvia/)做的，操作svg用[SVG.js](http://svgjs.com)，动画纯收撸。\n\n导航栏按钮的动画用[Segment.js](http://lmgonzalves.github.io/segment/)。\n\n博客部分，后台php，没用数据库，直接读json文件，这部分之后肯定会改用成熟的框架。写的是markdown，用[markdown.js](https://github.com/evilstreak/markdown-js/)转换成html.\n\nProjects和Me部分只是写了一些css3的动画，没有什么特殊的技巧。很多参考了[codrops](http://tympanus.net/codrops/category/tutorials/)这个网站，大家也可以去看看。\n\n[nprogess.js](https://github.com/rstacruz/nprogress)来做loading时的进度条，[Pjax](https://github.com/defunkt/jquery-pjax)做页面的跳转。\n\n大概就是这些，UI设计正在尝试突破，希望你会喜欢。"
		},
		{
			"title": "一些关于ARC的",
			"date": "2016.02.22",
			"content": "刚看了*《Objective-C高级编程 iOS与OS X多线程和内存管理》*的第一章，非常有意思，主要讲的是iOS中新引进的ARC系统。\n\n相信大部分人都很熟悉ARC系统了，其实本质上来说就是增加一个retainCount引用计数，来表示*当前有多少变量在使用一个对象*。如果计数为0，则销毁这个对象，因此大部分的销毁变量的代码都省去了，因为编译器会自动帮我们搞定这些。\n\n\n\n这是ARC的思想，c++中sharedPtr, weakPtr也是这么实现的。\n\n然而java管理内存用的是另一套东西：*垃圾收集器(Garbage Collector)*。GC会在每一个对象上增加一个字段，用来指向这个对象引用的其他对象。如果在一个代码块结束的时候，有一个对象没有任何其他对象去引用，那么他就是没用的，可以把他回收了，这也是很符合常理的对吧。其数据结构抽象出来我自己觉得很像一棵树，大家可以想象一下。\n\n\n\n回到ARC，虽然很好用，但是也有问题，会产生循环引用。概念就不必多说了，我们只要加上weak修饰符就可以。虽然看上去这样的解决方法很优雅，但是也有问题，因为weak修饰符不会持有对象，因此我们在使用带有weak修饰符的对象时，还是会创建一个strong的临时变量，并把他注册到autoreleasepool。像这样的一段代码: \n\n\t@autoreleasepool {\n\n\t\tid __strong obj = [[NSObject alloc] init];\n\n\t\tid __weak obj2 = obj;\n\n\t\tNSLog(@\"so?\", _objc_root_RetainCount(obj));\n\n\t}\n\n最终会输出2。当我们离开这个块的时候，strong的obj会release一次，在autoreleasepool中的临时变量会release一次，因此obj的计数为0，可以销毁，这在使用上没有问题。问题在于，每次使用weak类型的对象，都会创建一个临时变量并注册，这对cpu的负载是相当之大的，所以还是少用为妙，只有在循环引用时才使用。\n\n对了，现在常用@property属性声明，其属性和修饰符对应关系如下：\n\n\tassign\t\t\t\t__unsafe_unretained\n\n\tcopy\t\t\t\t__strong\n\n\tretain\t\t\t\t__strong\n\n\tstrong\t\t\t\t__strong\n\n\tunsafe_untained\t\t\t__unsafe_unretained\n\n\tweak\t\t\t\t__weak\n\nThat's all."
		},
		{
			"title": "Objective-C中的Block",
			"date": "2016.02.28",
			"content": "Block是什么呢？\n\n其实就是C++中的Lambda表达式，js中的匿名函数，swift中的闭包等。\n\nBlock能截取自动变量值，本质上来说，Block就是一个struct，我们截取到的变量值会存储在这个struct中，这个存储是拷贝存储，也就是说，值是不会随着之后的代码而改变的。更重要的一点是，我们无法对这样捕获到的值进行修改，除非我们增加block修饰符：\n\n\t__block id tmp;\t\n\n这个block修饰符本质也是一个struct，其中有一个指向自己的指针forwarding，这个指针的作用稍后会说明。\n\n作为一个struct，结合之前的ARC，我们知道会有一个retainCount，当一个Block被声明之后，是存在于栈上的，超出作用域就会废弃。但是，如果我们将Block复制到堆，就可以在之后的作用域中继续使用这个Block，而其block修饰符也会复制到堆中。复制的情况发生于以下：\n\n- 调用Block的copy方法\n\n- Block作为函数返回值返回时\n\n- 将Block赋值给有strong修饰符id类型的类\n\n- 在方法名中含有usingBlock的Cocoa框架方法\n\n那么，forwarding到底是用来干嘛的呢？因为Block可以在栈和堆两个地方，所以无论是栈中的Block还是堆中的Block，其内部的forwarding指针会始终指向堆的Block。\n\n还有的可能就是Block中的循环引用问题，但是这个问题真的不是问题，所以也就不多说了吧。"
		},
		{
			"title": "关于Grand Central Dispatch的一些知识",
			"date": "2016.03.01",
			"content": "此文中，将下划线命名的方法改成驼峰命名。\n\nGCD是什么，其实就是一堆控制线程的API，高度封装，而且性能优秀。\n\n为什么要有多线程呢？实际上我们打开一个app之后，主线程也就是我们看到的线程只有一个，但是我们会有很多后台的操作，比如下载图片，计算一个很复杂的公式等，如果在主线程中运行，那么用户就不能执行其他的操作。所以一般而言主线程用来更新UI和响应事件，其他的高负荷运算放在另一个线程中。\n\nGCD有两种queue，一种是serial dispatch queue，另外一种是concurrent dispatch queue。顾名思义，前者单线程，后者多线程。他们都是FIFO来执行任务的。\n\n我们有五个紫铜自带的dispatch queue，一个main dispatch queue，是serial的，四个global dispatch queue，是concurrent的，以优先级来区分。\n\n简单讲讲各个API的作用吧：\n\n- dispatchQueueCreate: 创建一个线程，此线程由程序员负责释放\n\n- dispatchSetTargetQueue: 设置线程的优先级\n\n- dispatchAfter: 在某个时间点的某个队列中执行某操作\n\n- dispatchAsync: 异步的将某个操作放入某个队列中执行\n\n- dispatchBarrierAsync: 完成此代码之前的操作再执行此代码，最后执行此代码之后的操作\n\n- dispatchSync: 将某个操作放入某个队列中执行，队列销毁后才能继续执行\n\n- dispatchApply: 按指定的次序将操作放入队列中执行\n\n- dispatchSuspend: 暂停某队列\n\n- dispatchResume: 恢复某队列\n\n简单说说GCD的实现吧，执行线程上操作的步骤如下：\n\n1. Block加入dispatch continuation\n\n2. 调用pthreadWorkqueueAdditemUp，将队列和continuation信息传回\n\n3. 调用pthreadWorkqueue，执行Block操作\n\n4. 如果队列中还有操作，则回到2\n\n差不多就是这些，具体的也要看项目的需求。\n\n"
		}
	]
}