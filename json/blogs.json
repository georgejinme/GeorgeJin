{
	"BLOGS":[
		{
			"title": "关于本站",
			"date": "2016.02.15",
			"content": "----------Update---------\n\n说一下project页面下面有箭头可以向左向右的。。然后增加了google analytics\n\n--------Update-------\n\n增加了[Disqus](https://disqus.com/home/explore/)作为评论系统，遗憾的是不能改字体。\n\n--------原文--------\n\n春节不上班，闲来无事就在家里写了一个个人网页。\n\n其实本意是想介绍一下自己，算是一份小小的简历，但在是否将博客功能嵌入这个问题上纠结许久，最后还是想直接集成在一个网页中。目前还没有用市面上的一些Blog框架，之后会考虑使用[Jekyll](http://jekyllrb.com)，不过都是后话了。\n\n说说用到的技术吧。\n\nLow Poly图用的是[Polyvia](http://zhangwenli.com/Polyvia/)做的，操作svg用[SVG.js](http://svgjs.com)，动画纯收撸。\n\n导航栏按钮的动画用[Segment.js](http://lmgonzalves.github.io/segment/)。\n\n博客部分，后台php，没用数据库，直接读json文件，这部分之后肯定会改用成熟的框架。写的是markdown，用[markdown.js](https://github.com/evilstreak/markdown-js/)转换成html.\n\nProjects和Me部分只是写了一些css3的动画，没有什么特殊的技巧。很多参考了[codrops](http://tympanus.net/codrops/category/tutorials/)这个网站，大家也可以去看看。\n\n[nprogess.js](https://github.com/rstacruz/nprogress)来做loading时的进度条，[Pjax](https://github.com/defunkt/jquery-pjax)做页面的跳转。\n\n大概就是这些，UI设计正在尝试突破，希望你会喜欢。"
		},
		{
			"title": "一些关于ARC的",
			"date": "2016.02.22",
			"content": "刚看了*《Objective-C高级编程 iOS与OS X多线程和内存管理》*的第一章，非常有意思，主要讲的是iOS中新引进的ARC系统。\n\n相信大部分人都很熟悉ARC系统了，其实本质上来说就是增加一个retainCount引用计数，来表示*当前有多少变量在使用一个对象*。如果计数为0，则销毁这个对象，因此大部分的销毁变量的代码都省去了，因为编译器会自动帮我们搞定这些。\n\n\n\n这是ARC的思想，c++中sharedPtr, weakPtr也是这么实现的。\n\n然而java管理内存用的是另一套东西：*垃圾收集器(Garbage Collector)*。GC会在每一个对象上增加一个字段，用来指向这个对象引用的其他对象。如果在一个代码块结束的时候，有一个对象没有任何其他对象去引用，那么他就是没用的，可以把他回收了，这也是很符合常理的对吧。其数据结构抽象出来我自己觉得很像一棵树，大家可以想象一下。\n\n\n\n回到ARC，虽然很好用，但是也有问题，会产生循环引用。概念就不必多说了，我们只要加上weak修饰符就可以。虽然看上去这样的解决方法很优雅，但是也有问题，因为weak修饰符不会持有对象，因此我们在使用带有weak修饰符的对象时，还是会创建一个strong的临时变量，并把他注册到autoreleasepool。像这样的一段代码: \n\n\t@autoreleasepool {\n\n\t\tid __strong obj = [[NSObject alloc] init];\n\n\t\tid __weak obj2 = obj;\n\n\t\tNSLog(@\"so?\", _objc_root_RetainCount(obj));\n\n\t}\n\n最终会输出2。当我们离开这个块的时候，strong的obj会release一次，在autoreleasepool中的临时变量会release一次，因此obj的计数为0，可以销毁，这在使用上没有问题。问题在于，每次使用weak类型的对象，都会创建一个临时变量并注册，这对cpu的负载是相当之大的，所以还是少用为妙，只有在循环引用时才使用。\n\n对了，现在常用@property属性声明，其属性和修饰符对应关系如下：\n\n\tassign\t\t\t\t__unsafe_unretained\n\n\tcopy\t\t\t\t__strong\n\n\tretain\t\t\t\t__strong\n\n\tstrong\t\t\t\t__strong\n\n\tunsafe_untained\t\t\t__unsafe_unretained\n\n\tweak\t\t\t\t__weak\n\nThat's all."
		},
		{
			"title": "Objective-C中的Block",
			"date": "2016.02.28",
			"content": "Block是什么呢？\n\n其实就是C++中的Lambda表达式，js中的匿名函数，swift中的闭包等。\n\nBlock能截取自动变量值，本质上来说，Block就是一个struct，我们截取到的变量值会存储在这个struct中，这个存储是拷贝存储，也就是说，值是不会随着之后的代码而改变的。更重要的一点是，我们无法对这样捕获到的值进行修改，除非我们增加block修饰符：\n\n\t__block id tmp;\t\n\n这个block修饰符本质也是一个struct，其中有一个指向自己的指针forwarding，这个指针的作用稍后会说明。\n\n作为一个struct，结合之前的ARC，我们知道会有一个retainCount，当一个Block被声明之后，是存在于栈上的，超出作用域就会废弃。但是，如果我们将Block复制到堆，就可以在之后的作用域中继续使用这个Block，而其block修饰符也会复制到堆中。复制的情况发生于以下：\n\n- 调用Block的copy方法\n\n- Block作为函数返回值返回时\n\n- 将Block赋值给有strong修饰符id类型的类\n\n- 在方法名中含有usingBlock的Cocoa框架方法\n\n那么，forwarding到底是用来干嘛的呢？因为Block可以在栈和堆两个地方，所以无论是栈中的Block还是堆中的Block，其内部的forwarding指针会始终指向堆的Block。\n\n还有的可能就是Block中的循环引用问题，但是这个问题真的不是问题，所以也就不多说了吧。"
		},
		{
			"title": "关于Grand Central Dispatch的一些知识",
			"date": "2016.03.01",
			"content": "GCD是什么，其实就是一堆控制线程的API，高度封装，而且性能优秀。\n\n为什么要有多线程呢？实际上我们打开一个app之后，主线程也就是我们看到的线程只有一个，但是我们会有很多后台的操作，比如下载图片，计算一个很复杂的公式等，如果在主线程中运行，那么用户就不能执行其他的操作。所以一般而言主线程用来更新UI和响应事件，其他的高负荷运算放在另一个线程中。\n\nGCD有两种queue，一种是serial dispatch queue，另外一种是concurrent dispatch queue。顾名思义，前者单线程，后者多线程。他们都是FIFO来执行任务的。\n\n我们有五个系统自带的dispatch queue，一个main dispatch queue，是serial的，四个global dispatch queue，是concurrent的，以优先级来区分。\n\n简单讲讲各个API的作用吧：\n\n- dispatchQueueCreate: 创建一个线程，此线程由程序员负责释放\n\n- dispatchSetTargetQueue: 设置线程的优先级\n\n- dispatchAfter: 在某个时间点的某个队列中执行某操作\n\n- dispatchAsync: 异步的将某个操作放入某个队列中执行\n\n- dispatchBarrierAsync: 完成此代码之前的操作再执行此代码，最后执行此代码之后的操作\n\n- dispatchSync: 将某个操作放入某个队列中执行，队列销毁后才能继续执行\n\n- dispatchApply: 按指定的次序将操作放入队列中执行\n\n- dispatchSuspend: 暂停某队列\n\n- dispatchResume: 恢复某队列\n\n简单说说GCD的实现吧，执行线程上操作的步骤如下：\n\n1. Block加入dispatch continuation\n\n2. 调用pthreadWorkqueueAdditemUp，将队列和continuation信息传回\n\n3. 调用pthreadWorkqueue，执行Block操作\n\n4. 如果队列中还有操作，则回到2\n\n差不多就是这些，具体的也要看项目的需求。\n\n"
		},
		{
			"title": "Objective-C语言相关",
			"date": "2016.03.08",
			"content": "最近正好在看*《Effective Objective-C 2.0》*，简单记录一下每一章节的内容吧，也算是复习了一下。\n\n那首先我们从语言本身开始说起。Objective-C是使用消息结构而非函数调用的，因此其运行时所执行的代码是由运行的环境来决定，而并非由编译器决定。\n\n这样的特性使得Objective-C非常之灵活，因为运行时确定，所以我们可以在写代码的时候展现一些黑科技，比如说运行时的代码替换，Swizzling等。相比而言Swift就更加严谨了，现在常见的一些运行时效果也是通过Objective-C的那一套来实现的。\n\n因为Objective-C的这样的特性，因此所有的Foundation中的对象都是保存在堆上而不是栈上，所以我们写代码的时候都使用指针，如下：\n\n\tNSString *someString = @\"the string\";\n\n当然，非Foundation对象，例如CGRect等，都是保存在栈上的。\n\n\n\n本书给我们的第一条建议是“在类的头文件中尽量少引入其他头文件”\n\n道理很简单，头文件a中引入了头文件b，相当于把头文件b的接口信息都暴露给了头文件a，这些信息是无用的。写代码的时候我们要确保其低耦合，因此这么做是非常值得的。\n\n那如果我们要使用b中的某个类呢？这时候可以用向前声明：\n\n\t@class SomeClass;\n\n这样我们可以直接使用类名，而把头文件的引入放在实现文件中了。\n\n除此之外，在头文件中引入其他头文件也容易产生循环引用，这与内存管理中的循环引用是类似的，不再重复了。\n\n\n\n关于对象，我们需要多用字面量语法，就像我们平时在c++，swift中做的那样。不同的是，我们需要把字面量转换成一个Foundation对象，只需要在字面量前加上@就可以了。例如：\n\n\tNSNumber *someNum = [NSNumber numberWithInt: 1];\n\nNSNumber *someNum = @1;\t\n\n上面两句话是等效的。\n\n所有的Foundation对象都可以这么定义，不过有几点需要注意：\n\n1. 不能出现nil\n\n2. 字典与数组中的元素/键值必须都是Foundation对象\n\n3. 用字面量创建出的对象都是不可变的\n\n\n\n此外，很多人喜欢用#define定义宏来表示某些常量，其实在OC中，完全可以用static const来取代。\n\n在编译器的处理上说，两者几乎没有区别，而常量增加了一个类型的信息，对于程序员更加友好。\n\n如果要定义一个全局的常量，可以使用extern关键字，头文件：\n\n\textern NSString *const someStr;\t\n\n实现文件中：\n\n\tNSString *const someStr = @\"fuck\";\t\n\n\n\n最后，聊一下枚举。\n\n我们可以使用enum来定义一个枚举类型，枚举类型的默认值也可以指定，因此我们可以将不同的值进行或运算，产生某种选项的效果。\n\n但是OC给我们提供了两个更加优雅的宏来定义枚举和选项：\n\n\ttypedef NS_ENUM(NSUIngeter, ConnectionState) {\n\t\tConnected,\n\t\tNotConnected,\n\t};\n\ttypedef NS_OPTION(NSUIngeter, PermittedDirection) {\n\t\tLeft,\n\t\tRight,\n\t\tUp,\n\t\tDown,\n\t};\n\n从名字就可以看出这两个宏是表示什么意思了吧，宏的第一个参数表示底层的存储类型，第二个参数表示枚举/选项类型的名字\n\n注意一点，我们在switch语句中，如果判断的是枚举类型，则不要加default，否则如果之后新增一种情况的话，很容易增加case语句，编译器也不会给我们任何的警告。\n\n"
		},
		{
			"title": "Objective-C中的消息",
			"date": "2016.03.22",
			"content": "我们先来介绍一下OC中属性的用法。属性就是我们在实际工程中运用的最多的形式，以@property开头。\n\n用属性有什么好处呢？简单来说，属性有利于我们对内存的管理，系统会自动生成一套setter和getter来处理对属性的读取和写入操作，同时满足用户指定的strong，week等修饰符。\n\n当然，只要在属性头加上@dynamic，系统就不会自动去生成setter和getter。\n\n同时，系统会为每一个属性增加一个实例的变量，在属性名前加上下划线作为实例变量的名字。实际上，系统的setter和getter都是对其实例变量进行操作。我们可以理解成属性把实例变量封装了起来。\n\n需要说明的是，我们在一个对象/类中，最好直接访问实例变量。如果用的是属性，那么会经过setter和getter方法，这是通过OC的方法派发来完成的，所以效率会比较低，而实例变量会绕过内存管理的语义，在速度上有优势。\n\n接下来说明一下对象等同性。\n\n在OC中，==比较的是指针，isEqual(或其类似方法)比较的是其内容。这个应该很好理解，我们应当使用isEqual。\n\n当然，我们可以对自己写的类写一个isEqual方法。\n\n如果我们想临时给一个类增加一个变量，有什么好用的方法呢？OC给我们提供了一种叫做关联对象的方法。有如下函数：\n\n\tvoid objc_setAssociatedObject(id object, void* key, id value, objc_AssociationPolicy policy)\n\tid objc_getAssociatedObject(id object, void* key)\n\n我们可以把关联对象想想成一个字典，需要存放时就增加一个键值对，取出增加的东西时也可以根据键进行选择。\n\n但是，此方法慎用，因为滥用的话我们会对一个对象失去可控性。\n\n我们都知道，OC是一种动态语言，对于一些方法的调用，都是在运行时才去使用。这种方法叫做传递消息，而传递消息最关键的方法就是objc&#95msgSend。\n\n\tid returnVal = objc_msgSend(someObject, @selector(msg:), parameter)\n\n其中，someObject为消息的接受者(调用函数方)， msg为选择子(函数名)。\n\n对于每一个类，我们有一个快速的映射表，如果我们第一次发送一个消息成功后，我们会把匹配的方法名和方法实现放在这个表中作为缓存。\n\n那么如果我们找不到一个方法呢？这时候我们就会调用OC的消息转发，具体来说，有三步：\n\n- 寻找是否有新增加的选择子\n\n这个方法要求我们提前写好代码，等着运行的时候动态插在类里面。常见于@dynamic属性。\n\n寻找选择子时，会调用的方法为:\n\n\t+ (Bool)resolveInstanceMethod: (SEL)selector\n\nselector即为我们所没有找到的选择子。\n\nclass_addMethod方法会为类增加一个方法实现，而这个实现的新方法名就是我们没有找到的选择子。\n\n- 寻找备援接受者，这限于在对象内的其他对象\n\n- 完整的消息转发，也就是改变调用目标。\n\n后两个在开发中其实非常的少见。\n\n接下来要介绍一个黑科技，叫做方法调配Method Swizzling\n\n由于OC的方法调用是在运行时才确定的，因此我们可以在运行时替换方法的实现。\n\n替换方法实现的方法为\n\n\tvoid method_exchangeImplementations(Method m1, Method m2)\n\n而根据方法名，得到其实现的方法为：\n\n\tMethod class_getInstanceMethod(Class aClass, SEL aSelector)\n\n我们只需要根据方法名，取出其实现然后交换就好啦！\n\n最后，介绍一下OC中的类。\n\n对于一个id类型的实例，其本质为一个struct：\n\n\ttypedef struct objc_object {\n\t\tClass isa;\n\t} *id;\n\nisa指向其所属的类\n\n而对于一个类，其也为一个struct，保存了一些类的数据。\n\n在这个struct中，也有一个Class类型的isa，指向这个类的元类。这个元类保存了这个类的一些元数据。而这个struct的super_class指针指向了这个类的父类。\n\n那么我们需要查询一个id实例的类型时，可以用如下方法：\n\n1. isMemberOfClass，查询实例是否为某个类\n\n2. isKindOfClass，查询实例是否为一个类或其子类\n\n当然，在比较类型时，我们可以用==运算符，因为每一个类在OC中都是单例的，只有一个类对象，也就没有地址不同这样的说法了。例如：\n\n\tif ([object class] == [SomeClass class]) {\n\t\t...\n\t}\n\n关于OC的语言特性，其实还有很多，但是其消息和动态的特性是最为关键的。"
		},
		{
			"title": "Objective-C中接口和API的设计",
			"date": "2016.04.02",
			"content": "首先有一点需要注意，在OC中是没有命名空间这个概念的。也就是说，我们用以区分不同变量的唯一方法就是变量名。\n\n所以我们会看到很多NS开头的对象，这些对象是Foundation库的。UI开头的对象是在UIKit库中。CF开头的对象是在CoreFoundation库中。\n\n所以我们自定义的库往往都用一些大写字母来开头，以区分不同的变量名。例如AFNetwork\n\n不过，所有两个字母前缀都被苹果所保留了，我们最好以三个字母前缀开头。\n\n在很多的OC类中，有许多不同的初始化方法。但是往往只有一个全能初始化方法(designated initializer)，其他所有初始化方法都是调用了这个全能初始化方法。如果这个类有一个子类，而子类的全能初始化方法名称与父类不同，那么我们必须重写其父类的全能初始化方法。\n\n当然，有时候我们不需要父类的全能初始化方法，那么我们重写的时候抛出异常即可。\n\n说说OC中打印的技巧。很多时候我们用NSLog来答应对象，比如：\n\n\tNSLog(@\"%@\", object)\n\n但是如果用这种方法来打印一个自定义的类的话，我们得到的信息只有类似于这样的:\n\n\t&ltSomeClass: 0x123456789ab&gt\n\n如果要打印出我们想要的信息，那么我们必须重写description，这个函数返回一个被打印出的字符串。\n\n我们在写一个类的时候，应当尽量使用不得变对象，只需要在property中加上readonly修饰符，这样我们不会为此生成setter，也就无法修改了。\n\n如果我们想在类的实现文件中对其进行修改，我们可以在class-continuation中修改他的修饰符为readwrite，这样我们就只能在类中对其进行修改，像这样。\n\n如果我们有一个业务逻辑上可变的collection，也不能将其直接公开，而应当是提供相应的方法，对其进行改变。\n\n除了属性以外，还有一些方法也是只在类中才能使用，OC没有办法把一个类标注成private的，因此我们需要加上一些前缀来区分他们。常用的可以是一个p加上下划线来进行处理。\n\n当然，私有的方法不应该出现在类的接口定义中。\n\n最后来说一下NSCopying这个协议。\n\n我们经常在NSString的属性加上copy这个修饰符，那这个修饰符到底有什么作用呢？\n\n事实上，在OC中，我们可以把一个可变对象赋给一个不可变的对象，而copy方法会返回一个不可变对象，即NSMutableString返回一个NSString。如果不这样做，那么原来的不可变对象可能会遭到别人修改。\n\n同理，mutableCopy方法会返回一个可变对象。\n\n如果我们需要对自己的类实现copy方法，我们需要在类中实现copyWithZone:方法，要实现mutableCopy的话，需要实现mutableCopyWithZone方法。\n\n在OC中，还有深拷贝和浅拷贝之分。浅拷贝仅仅拷贝了对象，而其底层的数据是共用一套的。深拷贝与此相反，同时拷贝了一套底层的数据。\n\n我们需要知道的是，如果一个不可变对象调用了copy方法，那么这时候是浅拷贝(因为本身和拷贝出来的对象都是不可变的，因此底层数据可以共用一套)。而如果其中之一为可变的，那么就是深拷贝，因为我们并不希望改变了其中一个值之后，另一个值也发生改变(对于不可变的值更是禁忌)。"
		},
		{
			"title": "Objective-C中的协议和分类",
			"date": "2016.04.04",
			"content": "delegate也是iOS编程中的一个重点，他定义了一套接口，如果一个对象想接受另一个对象的委托，则需要遵从此接口，以便成为其委托对象。\n\n这个委托的意思，实际上就是把函数的实现写在另一个类中，这个函数可以使用那个类的方法和数据成员。看上去就像是这个类帮别人做了写事情，成为委托的对象。\n\n委托的协议用@protocal来定义，在存放委托对象的类中，可以这么写：\n\n\t@property (nonatomic, weak) id <SomeProtocal> delegate;\n\n我们必须用weak修饰符来避免循环引用。\n\n上述代码的id指向遵循这个协议的类，表示我们不关心这个类具体是什么，我们只注意到这个类遵循了这个协议。\n\n当然，对于可选的方法，我们在前面加上@optional即可。\n\n下面来说说分类这个东西。OC中的分类对应swift就是其extension。我们可以通过分类把类实现代码按照逻辑分散到几个文件中:\n\n\t@interface SomeClass (AboutSomething)\n\t...\n\t@end\n\n分类中的方法是直接添加在类里面的，就好比是这个类的固有方法，因此会有覆写的可能性。\n\n需要注意的一点是，我们不要在分类中声明属性，因为在分类中是不能添加实例变量的。那不代表不能声明属性，通过@dynamic关键字，或者关联对象，都能够解决这个问题。但是保险起见，还是不要声明属性。\n\n当然，不是说所有的分类都不能，有一种分类叫做class-continuation就是例外，他有如下的特点：\n\n- 必须定义在其所接续的那个类的实现文件里\n\n- 唯一能够声明实例变量的分类\n\n- 分类没有名字\n\n- 分类中的所有属性和方法都是隐藏的，只能在本类中使用\n\n- 可以修改某属性的读写性，只读的属性可以在此分类中扩展为可读写\n\n比如这样：\n\n\t@interface SomeClass()\n\t...\n\t@end\n\n当然，协议也可以隐藏在class-continuation中：\n\n\t@interface SomeClass() <SomeProtocal>\n\t...\n\t@end"
		},
		{
			"title": "Objective-C中的系统框架",
			"date": "2016.04.13",
			"content": "iOS开发中有两个最重要的系统框架: Foundation和CoreFoundation，前者定义了OC对象，后者是C语言的API和数据结构。\n\n对于Foundation中的每一个OC对象，我们都有一个对应的CoreFoundation数据结构，使用__bridge可以进行无缝桥接\n\n__bridge: ARC仍然具备这个OC对象的所有权\n\n__bridge_retained: ARC交出这个OC对象的所有权，我们需要手动Release\n\n__bridge_transfer: ARC获得对象的所有权\n\n在OC中，我们遍历一个Collection有以下几种方法：\n\n1. 常规的for循环，和C语言一样\n\n2. NSEnumerator来遍历：nextObject方法来返回枚举里的下个对象，最后一个对象则返回nil\n\n3. 快速遍历：for...in\n\n4. 块遍历：enumerateObjectsUsingBlock, enumerateKeysAndObjectsUsingBlock\n\n块遍历可以提供对象，下标和指向是否终止的布尔值的指针\n\n在进行网络请求下载资源的时候，我们通常会把内容缓存下来。这时候应该采用NSCache\n\nNSCache会在系统资源将要耗尽的时候，自动删减缓存\n\n我们可以设置NSCache的对象的上线和总成本，来定义缓存删减其中对象的时机\n\ninitialize和load方法是OC对象两个比较特殊的初始化方法。前者在第一次使用对象的时候调用，后者在APP启动的时候调用\n\n需要注意的是，这两个方法都是阻塞的，因此我们不能放太多的操作在这两个方法之中。\n\n在load方法中我们不能调用其他类中的方法，因为初始化的顺序和时机是程序员不能确定的。"
		},
		{
			"title": "SJTULost的一些体会",
			"date": "2016.05.21",
			"content": "最近花了大约一个月的时间来开发这个SJTULost的项目，这个项目其实是我的数据库大作业，主要是一个交大学生使用的失物招领平台，从技术上介绍一下这个项目吧。\n\n前端，因为之前使用过一次React但是时间比较仓促，没有仔细的去研究过这个框架具体的使用方法。这次使用了React之后也搭配了Flux作为前端的框架。确实，有了Flux之后数据在前端的传递更加清晰，将Action和Store分隔开来的做法也使得代码有更强的可读性和可拓展性。当然，前端数据和后台数据放在了Action中完成，使用Ajax来对后台进行请求，返回的数据都是Json格式的。得到返回数据后再通知Store去更新其前端数据，并且显示在用户面前。\n\nAction里面主要分为两个部分，一个是UserAction，主要记录用户的操作，比如修改用户信息，登录等。还有一个叫InitializationAction，记录的是其他所有的操作，包括Finding和Found的读取，过滤，更新，查询等。\n\nStore的东西相对会多一点，数据库中每一个关系对象都会有一个Store，比如Finding，Found，ItemType和Place。同时，针对一些特定的功能我们也提供了其Store，比如Rank，后台将排好序的名字返回给前端，保存在Store中并最后显示。\n\n后台用的还是Django，一方面比较成熟，另一方面因为我之前也做过Django项目，所以学习成本会低很多。\n\n数据库的话，我一共建了五个表（不包括多对多关系的第三张表）。分别是Finding，Found，User，ItemType和Place。各个表之间的关系还是比较明确的。将Finding和Found分开也是因为这两者虽然字段很接近，但是其功能是截然不同的。\n\n接下来说说看这个项目中的一些难点。\n\n- 登录。项目中我没有自己设立登录系统，在User表中也是没有username和password这样的字段的。我使用的是交大的[Jaccount](http://developer.sjtu.edu.cn/wiki/JAccount)登录系统来进行判断用户的身份，也就是说，这个网站只有交大的同学才能够使用。Jaccount授权系统使用的是OAuth2，因为之前没有熟悉过，所以在开发的时候还是遇到了一些问题的，比如authorization和access token的两个url的回调函数必须是一致的，否则没有权限获取access token。得到用户信息之后，判断用户是否存在于数据库，如果不存在就创建一个新的元组。同时将这个用户在User表中的id保存在session里，有效期为两周，因此在两周内用户是不需要登录的。\n\n- 搜索。问题在于用户输入多个关键字时，我们应该怎么看待这些关键字的关系，是同时满足还是至少满足一个。因此我将与运算和或运算都加入到搜索系统里面，方便用户的查询。在后台使用queryset的field_contain参数，就能够从数据库里获取想要的信息。\n\n- 分页。分页的问题在于，我们除了需要获取那些部分的数据之外，还要获得所有数据的总数，这样才能知道什么时候用户是没有办法点击下一页的。我现在的实现中还存在着一个问题，用户每一次点击一页，相当于是重新计算了一遍再把数据返回前台。我理想的结果是，用户进入第一页之后，后台先返回第一页，然后在将后面一部分的页面读取出来缓存起来，这样如果用户点击下一页就不需要重新计算了，可以直接将数据返回前端。如果用户点击到了没有缓存过的一页，则再计算一遍。这样我们实际是利用用户浏览的时间才读取后面的内容，减少网页响应时间。\n\n- 选取时间。在网上找过一些时间的插件，但是都是用jQuery实现的，React版本的时间插件并不流行。最后选择了[react-datetime](https://github.com/YouCanBookMe/react-datetime)这个插件，能够和我的项目兼容。其中有一些props可以传递，包括dateFormat，timeFormat之类，都是可以在moment.js的网站上找到相应的字符格式。\n\n- 上传图片。抱歉，我实在没找到合适的React的上传文件的插件，因此还是用jQuery写成的[jQuery-File-Upload](https://github.com/blueimp/jQuery-File-Upload)插件。不过我将上传的动作放在了Action里，使得除了Action文件以外的地方都不会出现$这个符号。将图片传递给后台之后，使用qiniu的Python SDK将其上传到七牛云。最后把照片的url返回给前端，实时预览。\n\n关于这个项目的大概就是这些，如果有问题的话可以联系我。\n\n项目目前还没有服务器，有没有老司机推荐一个能跑python的，便宜的，免备案的服务器？"
		}
	]
}