{
	"BLOGS":[
		{
			"title": "关于本站",
			"date": "2016.02.15",
			"content": "----------Update---------\n\n说一下project页面下面有箭头可以向左向右的。。然后增加了google analytics\n\n--------Update-------\n\n增加了[Disqus](https://disqus.com/home/explore/)作为评论系统，遗憾的是不能改字体。\n\n--------原文--------\n\n春节不上班，闲来无事就在家里写了一个个人网页。\n\n其实本意是想介绍一下自己，算是一份小小的简历，但在是否将博客功能嵌入这个问题上纠结许久，最后还是想直接集成在一个网页中。目前还没有用市面上的一些Blog框架，之后会考虑使用[Jekyll](http://jekyllrb.com)，不过都是后话了。\n\n说说用到的技术吧。\n\nLow Poly图用的是[Polyvia](http://zhangwenli.com/Polyvia/)做的，操作svg用[SVG.js](http://svgjs.com)，动画纯收撸。\n\n导航栏按钮的动画用[Segment.js](http://lmgonzalves.github.io/segment/)。\n\n博客部分，后台php，没用数据库，直接读json文件，这部分之后肯定会改用成熟的框架。写的是markdown，用[markdown.js](https://github.com/evilstreak/markdown-js/)转换成html.\n\nProjects和Me部分只是写了一些css3的动画，没有什么特殊的技巧。很多参考了[codrops](http://tympanus.net/codrops/category/tutorials/)这个网站，大家也可以去看看。\n\n[nprogess.js](https://github.com/rstacruz/nprogress)来做loading时的进度条，[Pjax](https://github.com/defunkt/jquery-pjax)做页面的跳转。\n\n大概就是这些，UI设计正在尝试突破，希望你会喜欢。"
		},
		{
			"title": "一些关于ARC的",
			"date": "2016.02.22",
			"content": "刚看了*《Objective-C高级编程 iOS与OS X多线程和内存管理》*的第一章，非常有意思，主要讲的是iOS中新引进的ARC系统。\n\n相信大部分人都很熟悉ARC系统了，其实本质上来说就是增加一个retainCount引用计数，来表示*当前有多少变量在使用一个对象*。如果计数为0，则销毁这个对象，因此大部分的销毁变量的代码都省去了，因为编译器会自动帮我们搞定这些。\n\n\n\n这是ARC的思想，c++中sharedPtr, weakPtr也是这么实现的。\n\n然而java管理内存用的是另一套东西：*垃圾收集器(Garbage Collector)*。GC会在每一个对象上增加一个字段，用来指向这个对象引用的其他对象。如果在一个代码块结束的时候，有一个对象没有任何其他对象去引用，那么他就是没用的，可以把他回收了，这也是很符合常理的对吧。其数据结构抽象出来我自己觉得很像一棵树，大家可以想象一下。\n\n\n\n回到ARC，虽然很好用，但是也有问题，会产生循环引用。概念就不必多说了，我们只要加上weak修饰符就可以。虽然看上去这样的解决方法很优雅，但是也有问题，因为weak修饰符不会持有对象，因此我们在使用带有weak修饰符的对象时，还是会创建一个strong的临时变量，并把他注册到autoreleasepool。像这样的一段代码: \n\n\t@autoreleasepool {\n\n\t\tid __strong obj = [[NSObject alloc] init];\n\n\t\tid __weak obj2 = obj;\n\n\t\tNSLog(@\"so?\", _objc_root_RetainCount(obj));\n\n\t}\n\n最终会输出2。当我们离开这个块的时候，strong的obj会release一次，在autoreleasepool中的临时变量会release一次，因此obj的计数为0，可以销毁，这在使用上没有问题。问题在于，每次使用weak类型的对象，都会创建一个临时变量并注册，这对cpu的负载是相当之大的，所以还是少用为妙，只有在循环引用时才使用。\n\n对了，现在常用@property属性声明，其属性和修饰符对应关系如下：\n\n\tassign\t\t\t\t__unsafe_unretained\n\n\tcopy\t\t\t\t__strong\n\n\tretain\t\t\t\t__strong\n\n\tstrong\t\t\t\t__strong\n\n\tunsafe_untained\t\t\t__unsafe_unretained\n\n\tweak\t\t\t\t__weak\n\nThat's all."
		},
		{
			"title": "Objective-C中的Block",
			"date": "2016.02.28",
			"content": "Block是什么呢？\n\n其实就是C++中的Lambda表达式，js中的匿名函数，swift中的闭包等。\n\nBlock能截取自动变量值，本质上来说，Block就是一个struct，我们截取到的变量值会存储在这个struct中，这个存储是拷贝存储，也就是说，值是不会随着之后的代码而改变的。更重要的一点是，我们无法对这样捕获到的值进行修改，除非我们增加block修饰符：\n\n\t__block id tmp;\t\n\n这个block修饰符本质也是一个struct，其中有一个指向自己的指针forwarding，这个指针的作用稍后会说明。\n\n作为一个struct，结合之前的ARC，我们知道会有一个retainCount，当一个Block被声明之后，是存在于栈上的，超出作用域就会废弃。但是，如果我们将Block复制到堆，就可以在之后的作用域中继续使用这个Block，而其block修饰符也会复制到堆中。复制的情况发生于以下：\n\n- 调用Block的copy方法\n\n- Block作为函数返回值返回时\n\n- 将Block赋值给有strong修饰符id类型的类\n\n- 在方法名中含有usingBlock的Cocoa框架方法\n\n那么，forwarding到底是用来干嘛的呢？因为Block可以在栈和堆两个地方，所以无论是栈中的Block还是堆中的Block，其内部的forwarding指针会始终指向堆的Block。\n\n还有的可能就是Block中的循环引用问题，但是这个问题真的不是问题，所以也就不多说了吧。"
		},
		{
			"title": "关于Grand Central Dispatch的一些知识",
			"date": "2016.03.01",
			"content": "此文中，将下划线命名的方法改成驼峰命名。\n\nGCD是什么，其实就是一堆控制线程的API，高度封装，而且性能优秀。\n\n为什么要有多线程呢？实际上我们打开一个app之后，主线程也就是我们看到的线程只有一个，但是我们会有很多后台的操作，比如下载图片，计算一个很复杂的公式等，如果在主线程中运行，那么用户就不能执行其他的操作。所以一般而言主线程用来更新UI和响应事件，其他的高负荷运算放在另一个线程中。\n\nGCD有两种queue，一种是serial dispatch queue，另外一种是concurrent dispatch queue。顾名思义，前者单线程，后者多线程。他们都是FIFO来执行任务的。\n\n我们有五个系统自带的dispatch queue，一个main dispatch queue，是serial的，四个global dispatch queue，是concurrent的，以优先级来区分。\n\n简单讲讲各个API的作用吧：\n\n- dispatchQueueCreate: 创建一个线程，此线程由程序员负责释放\n\n- dispatchSetTargetQueue: 设置线程的优先级\n\n- dispatchAfter: 在某个时间点的某个队列中执行某操作\n\n- dispatchAsync: 异步的将某个操作放入某个队列中执行\n\n- dispatchBarrierAsync: 完成此代码之前的操作再执行此代码，最后执行此代码之后的操作\n\n- dispatchSync: 将某个操作放入某个队列中执行，队列销毁后才能继续执行\n\n- dispatchApply: 按指定的次序将操作放入队列中执行\n\n- dispatchSuspend: 暂停某队列\n\n- dispatchResume: 恢复某队列\n\n简单说说GCD的实现吧，执行线程上操作的步骤如下：\n\n1. Block加入dispatch continuation\n\n2. 调用pthreadWorkqueueAdditemUp，将队列和continuation信息传回\n\n3. 调用pthreadWorkqueue，执行Block操作\n\n4. 如果队列中还有操作，则回到2\n\n差不多就是这些，具体的也要看项目的需求。\n\n"
		},
		{
			"title": "Objective-C语言相关",
			"date": "2016.03.08",
			"content": "最近正好在看*《Effective Objective-C 2.0》*，简单记录一下每一章节的内容吧，也算是复习了一下。\n\n那首先我们从语言本身开始说起。Objective-C是使用消息结构而非函数调用的，因此其运行时所执行的代码是由运行的环境来决定，而并非由编译器决定。\n\n这样的特性使得Objective-C非常之灵活，因为运行时确定，所以我们可以在写代码的时候展现一些黑科技，比如说运行时的代码替换，Swizzling等。相比而言Swift就更加严谨了，现在常见的一些运行时效果也是通过Objective-C的那一套来实现的。\n\n因为Objective-C的这样的特性，因此所有的Foundation中的对象都是保存在堆上而不是栈上，所以我们写代码的时候都使用指针，如下：\n\n\tNSString *someString = @\"the string\";\n\n当然，非Foundation对象，例如CGRect等，都是保存在栈上的。\n\n\n\n本书给我们的第一条建议是“在类的头文件中尽量少引入其他头文件”\n\n道理很简单，头文件a中引入了头文件b，相当于把头文件b的接口信息都暴露给了头文件a，这些信息是无用的。写代码的时候我们要确保其低耦合，因此这么做是非常值得的。\n\n那如果我们要使用b中的某个类呢？这时候可以用向前声明：\n\n\t@class SomeClass;\n\n这样我们可以直接使用类名，而把头文件的引入放在实现文件中了。\n\n除此之外，在头文件中引入其他头文件也容易产生循环引用，这与内存管理中的循环引用是类似的，不再重复了。\n\n\n\n关于对象，我们需要多用字面量语法，就像我们平时在c++，swift中做的那样。不同的是，我们需要把字面量转换成一个Foundation对象，只需要在字面量前加上@就可以了。例如：\n\n\tNSNumber *someNum = [NSNumber numberWithInt: 1];\n\nNSNumber *someNum = @1;\t\n\n上面两句话是等效的。\n\n所有的Foundation对象都可以这么定义，不过有几点需要注意：\n\n1. 不能出现nil\n\n2. 字典与数组中的元素/键值必须都是Foundation对象\n\n3. 用字面量创建出的对象都是不可变的\n\n\n\n此外，很多人喜欢用#define定义宏来表示某些常量，其实在OC中，完全可以用static const来取代。\n\n在编译器的处理上说，两者几乎没有区别，而常量增加了一个类型的信息，对于程序员更加友好。\n\n如果要定义一个全局的常量，可以使用extern关键字，头文件：\n\n\textern NSString *const someStr;\t\n\n实现文件中：\n\n\tNSString *const someStr = @\"fuck\";\t\n\n\n\n最后，聊一下枚举。\n\n我们可以使用enum来定义一个枚举类型，枚举类型的默认值也可以指定，因此我们可以将不同的值进行或运算，产生某种选项的效果。\n\n但是OC给我们提供了两个更加优雅的宏来定义枚举和选项：\n\n\ttypedef NS_ENUM(NSUIngeter, ConnectionState) {\n\n\t\tConnected,\n\n\t\tNotConnected,\n\n\t};\n\n\ttypedef NS_OPTION(NSUIngeter, PermittedDirection) {\n\n\t\tLeft,\n\n\t\tRight,\n\n\t\tUp,\n\n\t\tDown,\n\n\t};\n\n从名字就可以看出这两个宏是表示什么意思了吧，宏的第一个参数表示底层的存储类型，第二个参数表示枚举/选项类型的名字\n\n注意一点，我们在switch语句中，如果判断的是枚举类型，则不要加default，否则如果之后新增一种情况的话，很容易增加case语句，编译器也不会给我们任何的警告。\n\n"
		},
		{
			"title": "Objective-C中的消息",
			"date": "2016.03.22",
			"content": "我们先来介绍一下OC中属性的用法。属性就是我们在实际工程中运用的最多的形式，以@property开头。\n\n用属性有什么好处呢？简单来说，属性有利于我们对内存的管理，系统会自动生成一套setter和getter来处理对属性的读取和写入操作，同时满足用户指定的strong，week等修饰符。\n\n当然，只要在属性头加上@dynamic，系统就不会自动去生成setter和getter。\n\n同时，系统会为每一个属性增加一个实例的变量，在属性名前加上下划线作为实例变量的名字。实际上，系统的setter和getter都是对其实例变量进行操作。我们可以理解成属性把实例变量封装了起来。\n\n需要说明的是，我们在一个对象/类中，最好直接访问实例变量。如果用的是属性，那么会经过setter和getter方法，这是通过OC的方法派发来完成的，所以效率会比较低，而实例变量会绕过内存管理的语义，在速度上有优势。\n\n接下来说明一下对象等同性。\n\n在OC中，==比较的是指针，isEqual(或其类似方法)比较的是其内容。这个应该很好理解，我们应当使用isEqual。\n\n当然，我们可以对自己写的类写一个isEqual方法。\n\n如果我们想临时给一个类增加一个变量，有什么好用的方法呢？OC给我们提供了一种叫做关联对象的方法。有如下函数：\n\n\tvoid objc_setAssociatedObject(id object, void* key, id value, objc_AssociationPolicy policy)\n\n\tid objc_getAssociatedObject(id object, void* key)\n\n我们可以把关联对象想想成一个字典，需要存放时就增加一个键值对，取出增加的东西时也可以根据键进行选择。\n\n但是，此方法慎用，因为滥用的话我们会对一个对象失去可控性。\n\n我们都知道，OC是一种动态语言，对于一些方法的调用，都是在运行时才去使用。这种方法叫做传递消息，而传递消息最关键的方法就是objc_msgSend。\n\n\tid returnVal = objc_msgSend(someObject, @selector(msg:), parameter)\n\n其中，someObject为消息的接受者(调用函数方)， msg为选择子(函数名)。\n\n对于每一个类，我们有一个快速的映射表，如果我们第一次发送一个消息成功后，我们会把匹配的方法名和方法实现放在这个表中作为缓存。\n\n那么如果我们找不到一个方法呢？这时候我们就会调用OC的消息转发，具体来说，有三步：\n\n- 寻找是否有新增加的选择子\n\n这个方法要求我们提前写好代码，等着运行的时候动态插在类里面。常见于@dynamic属性。\n\n寻找选择子时，会调用的方法为:\n\n\t+ (Bool)resolveInstanceMethod: (SEL)selector\n\nselector即为我们所没有找到的选择子。\n\nclass_addMethod方法会为类增加一个方法实现，而这个实现的新方法名就是我们没有找到的选择子。\n\n- 寻找备援接受者，这限于在对象内的其他对象\n\n- 完整的消息转发，也就是改变调用目标。\n\n后两个在开发中其实非常的少见。\n\n接下来要介绍一个黑科技，叫做方法调配Method Swizzling\n\n由于OC的方法调用是在运行时才确定的，因此我们可以在运行时替换方法的实现。\n\n替换方法实现的方法为\n\n\tvoid method_exchangeImplementations(Method m1, Method m2)\n\n而根据方法名，得到其实现的方法为：\n\n\tMethod class_getInstanceMethod(Class aClass, SEL aSelector)\n\n我们只需要根据方法名，取出其实现然后交换就好啦！\n\n最后，介绍一下OC中的类。\n\n对于一个id类型的实例，其本质为一个struct：\n\n\ttypedef struct objc_object {\n\n\t\tClass isa;\n\n\t} *id;\n\nisa指向其所属的类\n\n而对于一个类，其也为一个struct，保存了一些类的数据。\n\n在这个struct中，也有一个Class类型的isa，指向这个类的元类。这个元类保存了这个类的一些元数据。而这个struct的super_class指针指向了这个类的父类。\n\n那么我们需要查询一个id实例的类型时，可以用如下方法：\n\n1. isMemberOfClass，查询实例是否为某个类\n\n2. isKindOfClass，查询实例是否为一个类或其子类\n\n当然，在比较类型时，我们可以用==运算符，因为每一个类在OC中都是单例的，只有一个类对象，也就没有地址不同这样的说法了。例如：\n\n\tif ([object class] == [SomeClass class]) {\n\n\t\t...\n\n\t}\n\n关于OC的语言特性，其实还有很多，但是其消息和动态的特性是最为关键的。"
		}
	]
}